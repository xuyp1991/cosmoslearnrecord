# Staking Tombstone

## Abstract

在当前的" slashing"模块实现中，当共识引擎将验证程序的共识错误通知状态机时，验证程序会被部分削减，并置于"监禁期"，即不允许使用的时间段 重新加入验证器集。 但是，由于共识错误和ABCI的性质，在违规发生和违规到达状态机的证据之间可能会有延迟（这是存在未绑定期的主要原因之一）。

>注意：逻辑删除概念仅适用于在违规发生和证据到达状态机之间存在延迟的故障。例如，由于不可预测的证据八卦层延迟以及验证器有选择地揭示双重签名的能力（例如，对不经常在线的轻客户端），验证者进行双重签名的证据可能需要一段时间才能到达状态机。另一方面，只要发生违规行为，就可以立即检测到砍伐活动，因此不需要砍伐期。验证者将立即进入监狱，他们在入狱之前不能犯另一个生气。将来，可能还会有其他类型的拜占庭式故障具有延迟（例如，将无效提案的证据作为交易提交）。实施后，必须决定这些未来的
拜占庭式断层将导致墓碑破裂（如果不是，则斜线数量不会受到斜线周期的限制）。

在当前的系统设计中，一旦将验证器放入共识错误的监狱中，则在` JailPeriod`之后，他们将被允许向" unjail"自身发送事务，从而重新加入验证器集。

slashing模块的"设计愿望"之一是，如果在执行证据之前发生了多次违规行为（并且将验证者投入了监狱），则应仅对单个最严重的违规行为进行惩罚，而不是累加。 例如，如果事件序列是：

1. Validator A commits Infraction 1 (worth 30% slash)
2. Validator A commits Infraction 2 (worth 40% slash)
3. Validator A commits Infraction 3 (worth 35% slash)
4. Evidence for Infraction 1 reaches state machine (and validator is put in jail)
5. Evidence for Infraction 2 reaches state machine
6. Evidence for Infraction 3 reaches state machine

只有Infraction 2的斜线才有效，因为它是最高的。 这样做是为了使在验证者的共识密钥遭到破坏的情况下，即使黑客对多个块进行了双重签名，也只会对它们进行一次惩罚。 因为，必须使用验证程序的操作员密钥进行解锁，所以他们有机会重新保护其共识密钥，然后使用操作员密钥发出已准备就绪的信号。 我们称此为仅跟踪最大违规的时间段，即"削减期"。

一旦验证者通过自我约束重新加入，我们将开始一个新的削减期。 如果他们在开狱后犯下新的违规行为，则该行为将在上一个削减期最严重的违规行为之上被累计削减。

但是，虽然违规行为是根据削减期进行分组的，但是由于可以在违规之后直至" unbondingPeriod"之前提交证据，因此我们仍然必须允许将证据提交到之前的削减期。 例如，如果事件序列是：

1. Validator A commits Infraction 1 (worth 30% slash)
2. Validator A commits Infraction 2 (worth 40% slash)
3. Evidence for Infraction 1 reaches state machine (and Validator A is put in jail)
4. Validator A unjails

我们现在处在一个新的削减期，但是我们仍然需要为之前的违规行为敞开大门，因为可能仍会出现违反2的证据。随着削减期数的增加，这将增加我们的复杂性 跟踪每个削减期的最高违规量。

>注意：目前，根据`slashing`模块规范，每次取消验证器然后重新绑定时，都会创建一个新的削减期。 这可能应该更改为已监禁/未监禁。 有关更多详细信息，请参见问题[＃3205]（https://github.com/cosmos/cosmos-sdk/issues/3205）。 对于其余的内容，我将假定我们仅在验证者被送进监狱时才开始一个新的削减期。

斜线段的最大数目为len（UnbondingPeriod）/ len（JailPeriod）。 Gaia当前针对" UnbondingPeriod"和" JailPeriod"的默认值分别为3周和2天。 这意味着每个验证者最多可能同时跟踪11个削减期。 如果我们将JailPeriod设置为> = UnbondingPeriod`，则只需跟踪1个斜杠周期（即不必跟踪斜杠周期）。

当前，在监禁期间的实施中，一旦验证者下狱，所有委派给他们的委托人（没有解除约束/重新委派）将与他们在一起。鉴于共识安全性错误如此严重（比活动性错误更严重），谨慎的做法是让委派者不要"自动重新绑定"到验证者。因此，我们建议将提交共识安全性错误的验证者的"入狱时间"设置为"无限"（即墓碑状态）。这实质上是将验证器踢出验证器集，并且不允许他们重新进入验证器集。他们的所有委托人（包括操作员本身）都必须解除绑定或重新委托。验证者操作员可以根据需要使用新的操作员密钥和共识密钥来创建新的验证器，但是他们必须"重新赚取"其授权。为了使验证器处于逻辑删除状态，我们将DoubleSignJailEndTime设置为time.Unix（253402300800），这是Amino支持的最长时间。

实施墓碑系统并摆脱削减期跟踪将使slashing模块的方式变得更加简单，特别是因为我们可以删除`staking`模块消耗的`slashing`模块中定义的所有钩子（`slashing` 模块仍然使用在`staking`中定义的钩子。

### Single slashing amount

可以进行的另一个优化是，如果我们假设将Tendermint共识的所有ABCI错误都削减到同一水平，则不必跟踪"最大削减"。 一旦发生ABCI故障，我们不必担心比较潜在的未来故障以找到最大值。

当前，唯一的Tendermint ABCI错误是：

-不合理的预先承诺（双重迹象）

目前计划在不久的将来包括以下故障：

-处于未绑定阶段时，请签署预提交（需要确保轻客户端两部分安全）

鉴于这些故障都是拜占庭式故障造成的，我们很可能希望均等地削减它们，因此我们可以实施上述更改。

>注意：此更改可能对当前的Tendermint共识有意义，但对于不同的共识算法或可能希望在不同级别进行惩罚（例如，部分削减）的Tendermint的未来版本可能没有意义。